# -*- coding: utf-8 -*-
"""mastering-python-set1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fpUCrs1vx_p7V5UpZdI2bRzoYj-hYl_o

**1. Swap values**

swap the values of two variables without using a temporary variable:
"""

# a,b = b,a
a = 10
b = 20

a, b = b, a

print(a)
print(b)

"""2. List Comprehensions
Use list comprehensions for concise and redable code:
"""

Squared_number = [x**2 for x in range(1, 11)]

"""**3. Multiple Assignmets**

Assign Multiple variables in a single line:
"""

x,y,z = 1,2,3

"""**4. Unpacking**

Unpack elements of a list or tuple into separate variables:
"""

numbers = [1,2,3]
a,b,c = numbers

a

b

c

"""**5. Merge Dictionaries**

Merge two dictionaries in python
"""

dict1 = {'a':1,'b':2}
dict2 = {'c':3,'d':4}
merge_dict = {**dict1,**dict2}

merge_dict

"""**6. Ternary Operator**

Use a ternary Operator for concise conditional expressions:

"""

x = 10
result = "positive" if x > 0 else "non-positive"

result

x = -29
result = "positive" if x > 0 else "non-positive"

result

"""**7 Default Dictionary**

Create a dictionary with default values for missing keys:

"""

from collections import defaultdict
d = defaultdict(int)# default value for missing is 0

for i in range(10):
  d[i] += 1

print(d)

"""**8.ZIP Function**

Combine two or more lists using zip function:
"""

names = ['Amar',"Jeet","Kumar"]
scores = [85,98,89]
students = zip(names, scores)

# # print the tuple
# print(next(students))

students_list = list(students)
print(students_list)

"""**9. Enumerate Function**

Use **enumerate** to get both the index and value of elements in a list:

"""

fruits = ['apple','banana','cherry']
for index, fruit in enumerate(fruits):
    print(f"index {index}: {fruits}")

"""**10 any and all**

Check if any or all elements in sequence satisfy a condition:

"""

numbers = [2,4,6,5,6,7,8]
any_even = any(x % 2 == 0 for x in numbers)
any_even

all_even = all(x % 2 == 0 for x in numbers)
all_even

"""**11. One Liner function**

Create one-linear functions using lambda:
"""

square = lambda x: x**2

print(square(5))

"""**12. Filter and map**

Use filter and map for compact and expressive list operations
"""

#To filter a list
numbers = [1, 2, 3, 4, 5]

even_numbers = list(filter(lambda x: x % 2 == 0, numbers))

print(even_numbers)

#To map a list
numbers = [1, 2, 3, 4, 5]

squared = list(map(lambda x: x ** 2, numbers))

print(squared)

"""**13. Sorted Function**

Sort a list while keeping the original intact
"""

numbers = [3,1,4,5,9,2]
sorted_numbers = sorted(numbers)

sorted_numbers

"""**14. Chain Comparison**

Chain comparison for cleaner code:
"""

x = 10
if 0 < x < 20:
    print("x is the range (0, 20)")

"""**15. Dictionary Comprehensions**

Use dictionary comprehensions for concise dictionary creation

"""

squared_dict = {x: x**2 for x in range(1, 11)}

squared_dict

"""**16. zip(*reversed()) to transpose a Matrix**

Transpose a matrix using zip and reversed functions:

"""

matrix = [
    [1,2,3],
    [4,5,6],
    [7,8,9]
]
transposed_matrix = [list(row) for row in zip(*reversed(matrix))]

transposed_matrix

"""**17. set for unique Elements**

Use set to get unique elemnets from a list:

"""

numbers = [1,2,3,4,5,6,7,8,1,1,1,3,4,5,5,6,3,4,5,5,3]
unique_numbers = list(set(numbers))

unique_numbers

"""**18. collctions.Counter**

Use Counter to count occurences of elements in a list:

"""

from collections import Counter
numbers = [1,2,3,1,2,3,2,3,2,4,2,4,5,2,5,2,4,2,5,6,7,4]
number_counts = Counter(numbers)

number_counts

"""**19. sum with a starting value**

Use sum with a string value for accumulating values:
"""

numbers = [1,2,3,4,5]
sum_with_start = sum(numbers, 10)
sum_with_start2 = sum(numbers, 30)

print(sum_with_start)
print(sum_with_start2)

"""**20. collections.defaultdict with list**

Use defaultdict with a list as the default factory:

"""

from collections import defaultdict

colors = [("apple", "red"), ("banana", "yellow"), ("cherry", "red"),
("orange", "orange")]

color_dict = defaultdict(list)

for fruit, color in colors:
    color_dict[color].append(fruit)

"""
The defaultdict object is a very useful tool for working with dictionaries.
It can be used to avoid the need to check for the existence of a key before accessing it.
This can be helpful for code that needs to iterate over a large number of keys,
as it can prevent unnecessary errors.
"""
print(color_dict)

"""**21. The with statement for File Handling**

Use the with statement for cleaner file handling
"""

# with open ("file.txt","r") as file:
#     content = file.read()
#  #No need to manually close the file, it's automatically handled by the 'with' block.

try:
    with open("file.txt", "r") as file:
        content = file.read()
except FileNotFoundError as e:
    print("File not found")

"""**22. isinstance for Type checking**

Use isinstance for type checking instead of using type:

"""

value = 10

if isinstance(value, int):
    print("The value is an integer")
else:
    print("The value is not an integer")

"""**23. Multiple Inheritance**

Use multiple inheritance to create flexible class hierarchies:
"""

class A:
    def method(self):
        print("Method from class A")
class B:
    def method(self):
        print("Method from class B")
class C(A, B):
    pass
instance = C()
instance.method() # Output: "Method from class A"

"""**24. Decorators**

Decorators allow you to modify or enhance the behavior of functions or methods:

"""

def my_decorator(func):
    def wrapper(*args,**kwargs):
        print("Something is happening before the function is called")
        result = func(*args, **kwargs)
        print("Something is happening after the function is called.")
        return result
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()

"""*A decorator is a function that takes another function as its argument and returns a new function. The new function is called the wrapper function. The wrapper function can do anything that the original function can do, and it can also do additional things, such as logging, timing, or adding security.*

**25. functools.partial**

Use functools.partial to create functions with fixed arguments:
"""

import functools

def power(base, exponent):
    return base ** exponent

square = functools.partial(power, exponent=2)
cube = functools.partial(power, exponent=3)

print(square(5))
print(cube(5))

"""**26. collections.namedtuple**

Create simple classes with named fields using namedtuple:

"""

from collections import namedtuple

Person = namedtuple("Person",["name","age"])
Person = Person("Amar", 30)
print(Person.name)
print(Person.age)

"""**27. global() and locals()**

Access global and local variables dynamically:


"""

x = 10

def my_function():
    y = 20
    print(locals())
    print(globals()['x'])

my_function()

"""**28. List Concatenation**

Use + to concatenate lists:

"""

list1 = [1,2,3]
list2 = [4,5,6]

concatenated_list = list1 +list2
print(concatenated_list)

"""**29. Strin Formatting**

Use f-string or str.format for string formatting:
"""

name = "Amar"
age = 25
print(f"My name is {name} and I am {age} years old.")
print("My name is {} and I am {} years old.".format(name, age))

"""**30. try, except, and else**

Use try, except and else for more informative error handling:
"""

try:
    result = 10 / 0
except ZeroDivisionError as e:
    print(f"Error: {e}")
else:
    print(f"Result: {result}")

"""**31. collections.deque**

Use deque for efficient amd thread-safe appends and pops from both ends:

"""

from collections import deque
queue = deque()
queue.append(1)
queue.append(2)
queue.append(3)
queue.append(4)

print(queue)

queue.popleft()

print(queue)

"""**32 Shuffling a List**

Use random.shuffle to shuffle elements in a list:

"""

import random
numbers = [1,2,3,4,5]
random.shuffle(numbers)
print(numbers)

"""**33. Dictionary Get with Default Value**

Use get to access dictionary values with a default value if the
key is not present:

"""

my_dict = {'a': 1,'b':2}
value = my_dict.get('c',0)

print(value)

